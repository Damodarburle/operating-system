5. Write a program to compute the average waiting time and turnaround time based on Preemptive shortest remaining processing time first (SRPT) algorithm for the following set of processes, with the arrival times and the CPU-burst times given in milliseconds
Process   Arrival Time Burst Time
P1		0		 5
P2		1		   3
P3		2		   3
P4		4		   1

sol:

#include <stdio.h>

struct Process {
    int arrival_time;
    int burst_time;
    int remaining_time;
    int completion_time;
    int waiting_time;
    int turnaround_time;
};

void swap(struct Process *a, struct Process *b) {
    struct Process temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int n = 4; // Number of processes
    struct Process processes[n];
    int total_waiting_time = 0;
    int total_turnaround_time = 0;

    // Input the arrival time and burst time of each process
    for (int i = 0; i < n; i++) {
        printf("Enter the arrival time and burst time of P%d: ", i+1);
        scanf("%d %d", &processes[i].arrival_time, &processes[i].burst_time);
        processes[i].remaining_time = processes[i].burst_time;
    }

    // Sort the processes by arrival time
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (processes[j].arrival_time > processes[j+1].arrival_time) {
                swap(&processes[j], &processes[j+1]);
            }
        }
    }

    int current_time = 0;
    int completed_processes = 0;
    int shortest_process_index = -1;
    int shortest_process_remaining_time = -1;

    // Run the SRPT algorithm
    while (completed_processes < n) {
        shortest_process_index = -1;
        shortest_process_remaining_time = -1;

        // Find the process with the shortest remaining time
        for (int i = 0; i < n; i++) {
            if (processes[i].arrival_time <= current_time && processes[i].remaining_time > 0) {
                if (shortest_process_index == -1 || processes[i].remaining_time < shortest_process_remaining_time) {
                    shortest_process_index = i;
                    shortest_process_remaining_time = processes[i].remaining_time;
                }
            }
        }

        if (shortest_process_index == -1) {
            // No process is available to execute
            current_time++;
        } else {
            // Execute the shortest process for 1 millisecond
            processes[shortest_process_index].remaining_time--;
            current_time++;

            if (processes[shortest_process_index].remaining_time == 0) {
                // Update the completion time and calculate waiting time and turnaround time
                processes[shortest_process_index].completion_time = current_time;
                processes[shortest_process_index].turnaround_time = processes[shortest_process_index].completion_time - processes[shortest_process_index].arrival_time;
                processes[shortest_process_index].waiting_time = processes[shortest_process_index].turnaround_time - processes[shortest_process_index].burst_time;

                // Add the waiting time and turnaround time to the total
                total_waiting_time += processes[shortest_process_index].waiting_time;
                total_turnaround_time += processes[shortest_process_index].turnaround_time;

                completed_processes++;
            }
        }
    }

    // Print the results
    printf("Process\t Arrival Time\t Burst Time\t Waiting Time\t Turnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t\t %d\t\t %d\t\t %d\t\t %d\n", i+1, processes[i].arrival_time, processes[i].burst_time, processes[i].waiting_time, processes[i].turnaround_time);
}
printf("Average Waiting Time: %.2f\n", (float)total_waiting_time/n);
printf("Average Turnaround Time: %.2f\n", (float)total_turnaround_time/n);
return 0;
}



